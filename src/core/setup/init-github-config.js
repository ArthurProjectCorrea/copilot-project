const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

// Configura√ß√£o dos diret√≥rios e arquivos
const CONFIG = {
  directories: ['chatmodes', 'instructions', 'prompts'],
  packageName: '@copilot-kit/chat-integration',
  copyRulesFile: 'copy-rules.json',
};

/**
 * Carrega as regras de c√≥pia do arquivo JSON
 */
function loadCopyRules(basePath) {
  const rulesPath = path.join(basePath, 'scripts', CONFIG.copyRulesFile);

  try {
    if (fs.existsSync(rulesPath)) {
      const rules = JSON.parse(fs.readFileSync(rulesPath, 'utf8'));
      console.log('üìã Copy rules loaded from:', rulesPath);
      return rules;
    }
  } catch (error) {
    console.warn(
      '‚ö†Ô∏è Could not load copy rules:',
      error instanceof Error ? error.message : String(error)
    );
  }

  // Regras padr√£o se n√£o conseguir carregar o arquivo
  console.log('üìã Using default copy rules');
  return {
    copyRules: {
      instructions: {
        enabled: true,
        files: ['*.instructions.md'],
        exclude: [],
      },
      prompts: { enabled: true, files: ['*.prompt.md'], exclude: [] },
      chatmodes: { enabled: true, files: ['*.chatmode.md'], exclude: [] },
    },
    globalExcludes: ['version.json', '*.log', '*.tmp', '.DS_Store'],
  };
}

/**
 * Verifica se um arquivo deve ser copiado baseado nas regras
 */
function shouldCopyFile(fileName, directory, copyRules) {
  // Verifica exclus√µes globais
  if (
    copyRules.globalExcludes &&
    copyRules.globalExcludes.some((pattern) => matchPattern(fileName, pattern))
  ) {
    return false;
  }

  // Verifica regras espec√≠ficas do diret√≥rio
  const dirRule = copyRules.copyRules[directory];
  if (!dirRule || !dirRule.enabled) {
    return false;
  }

  // Verifica exclus√µes espec√≠ficas do diret√≥rio
  if (dirRule.exclude && dirRule.exclude.some((pattern) => matchPattern(fileName, pattern))) {
    return false;
  }

  // Verifica se o arquivo corresponde aos padr√µes permitidos
  if (dirRule.files && dirRule.files.length > 0) {
    return dirRule.files.some((pattern) => matchPattern(fileName, pattern));
  }

  return true;
}

/**
 * Fun√ß√£o simples para correspond√™ncia de padr√µes (suporte b√°sico a wildcards)
 */
function matchPattern(fileName, pattern) {
  // Converte padr√£o em regex simples
  const regexPattern = pattern.replace(/\./g, '\\.').replace(/\*/g, '.*').replace(/\?/g, '.');

  const regex = new RegExp(`^${regexPattern}$`, 'i');
  return regex.test(fileName);
}

/**
 * Utilit√°rios
 */
function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
    console.log('üìÅ Created directory:', dir);
  }
}

function calculateFileHash(filePath) {
  if (!fs.existsSync(filePath)) return null;
  const content = fs.readFileSync(filePath, 'utf8');
  return crypto.createHash('sha256').update(content).digest('hex');
}

function copyFile(src, dest) {
  ensureDir(path.dirname(dest));
  fs.copyFileSync(src, dest);
  console.log('‚úÖ Created/Updated:', dest);
}

/**
 * Carrega informa√ß√µes de vers√£o
 */
function loadVersionInfo(sourcePath, targetPath) {
  const sourceVersionPath = path.join(sourcePath, '.github', 'version.json');
  const targetVersionPath = path.join(targetPath, '.github', 'version.json');

  let sourceVersion = null;
  let targetVersion = null;

  try {
    if (fs.existsSync(sourceVersionPath)) {
      sourceVersion = JSON.parse(fs.readFileSync(sourceVersionPath, 'utf8'));
    }
  } catch (error) {
    console.warn(
      '‚ö†Ô∏è Could not read source version.json:',
      error instanceof Error ? error.message : String(error)
    );
  }

  try {
    if (fs.existsSync(targetVersionPath)) {
      targetVersion = JSON.parse(fs.readFileSync(targetVersionPath, 'utf8'));
    }
  } catch (error) {
    console.warn(
      '‚ö†Ô∏è Could not read target version.json:',
      error instanceof Error ? error.message : String(error)
    );
  }

  return { sourceVersion, targetVersion };
}

/**
 * Verifica se um arquivo precisa ser atualizado
 */
function needsUpdate(sourceFile, targetFile, sourceVersion, targetVersion) {
  // Se o arquivo de destino n√£o existe, precisa ser criado
  if (!fs.existsSync(targetFile)) {
    return true;
  }

  // Se temos informa√ß√£o de vers√£o e a fonte √© mais nova
  if (sourceVersion && targetVersion) {
    if (sourceVersion.version !== targetVersion.version) {
      return true;
    }
    if (sourceVersion.lastUpdated > targetVersion.lastUpdated) {
      return true;
    }
  }

  // Compara√ß√£o por hash dos arquivos
  const sourceHash = calculateFileHash(sourceFile);
  const targetHash = calculateFileHash(targetFile);

  return sourceHash !== targetHash;
}

/**
 * Copia arquivos de configura√ß√£o de um diret√≥rio para outro
 */
function copyConfigFiles(sourceDir, targetDir, sourceVersion, targetVersion, copyRules) {
  let updatedFiles = 0;
  let createdFiles = 0;
  let skippedFiles = 0;

  CONFIG.directories.forEach((dir) => {
    const sourceDirPath = path.join(sourceDir, dir);
    const targetDirPath = path.join(targetDir, dir);

    if (!fs.existsSync(sourceDirPath)) {
      console.warn(`‚ö†Ô∏è Source directory not found: ${sourceDirPath}`);
      return;
    }

    ensureDir(targetDirPath);

    const files = fs.readdirSync(sourceDirPath);
    files.forEach((file) => {
      // Verifica se o arquivo deve ser copiado baseado nas regras
      if (!shouldCopyFile(file, dir, copyRules)) {
        console.log(`‚è≠Ô∏è Skipped (rule): ${path.join(dir, file)}`);
        skippedFiles++;
        return;
      }

      if (file.endsWith('.md')) {
        const sourceFile = path.join(sourceDirPath, file);
        const targetFile = path.join(targetDirPath, file);

        const fileExists = fs.existsSync(targetFile);

        if (needsUpdate(sourceFile, targetFile, sourceVersion, targetVersion)) {
          copyFile(sourceFile, targetFile);
          if (fileExists) {
            updatedFiles++;
          } else {
            createdFiles++;
          }
        } else {
          console.log('‚ÑπÔ∏è File up to date:', targetFile);
        }
      } else {
        console.log(`‚è≠Ô∏è Skipped (not .md): ${path.join(dir, file)}`);
        skippedFiles++;
      }
    });
  });

  return { updatedFiles, createdFiles, skippedFiles };
}

/**
 * Fun√ß√£o principal
 */
function initGithubConfig(forceRun = false) {
  const base = process.cwd();
  const packagePath = path.join(base, 'node_modules', CONFIG.packageName);
  const targetGithubPath = path.join(base, '.github');

  // Detecta contexto de execu√ß√£o
  const isUpdate = process.env.npm_lifecycle_event === 'postupdate';
  const isPrepack = process.env.npm_lifecycle_event === 'prepack';
  const isInstall = process.env.npm_lifecycle_event === 'postinstall';

  const context = isUpdate
    ? 'Update'
    : isPrepack
      ? 'Package preparation'
      : isInstall
        ? 'Installation'
        : 'Manual execution';

  console.log(`üöÄ Initializing GitHub Copilot configuration... (${context})`);
  console.log('üìç Working directory:', base);

  // Verifica se estamos no pr√≥prio projeto copilot-project
  // Checka se existe package.json com nome "copilot-project" e as pastas necess√°rias
  let isSourceProject = false;
  const packageJsonPath = path.join(base, 'package.json');

  if (fs.existsSync(packageJsonPath)) {
    try {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      const hasCopilotProjectName = packageJson.name === CONFIG.packageName;
      const hasConfigDirs = CONFIG.directories.every((dir) =>
        fs.existsSync(path.join(base, '.github', dir))
      );
      isSourceProject = hasCopilotProjectName && hasConfigDirs;
    } catch {
      // Ignore package.json parsing errors
    }
  }

  // Durante desenvolvimento do @copilot-kit/chat-integration, pula a execu√ß√£o a menos que seja for√ßada
  if (isSourceProject && !forceRun && !isInstall) {
    console.log(
      'üí° This appears to be the source @copilot-kit/chat-integration. Skipping initialization.'
    );
    console.log('üí° Use --force flag to run anyway for testing purposes.');
    return;
  }

  // Se estivermos no projeto fonte com --force, use os arquivos locais para teste
  let sourceGithubPath;
  if (isSourceProject && forceRun) {
    sourceGithubPath = path.join(base, '.github');
    console.log('üß™ Force mode: Using local .github files for testing');
  } else {
    sourceGithubPath = path.join(packagePath, '.github');
  }

  // Verifica se os arquivos fonte existem
  if (!fs.existsSync(sourceGithubPath)) {
    console.error('‚ùå Source .github configuration not found.');
    console.error(`Expected path: ${sourceGithubPath}`);
    if (!isSourceProject) {
      console.log(
        'üí° Make sure @copilot-kit/chat-integration is properly installed as a dependency.'
      );
    }
    process.exit(1);
  }

  // Carrega informa√ß√µes de vers√£o
  const versionSourcePath = isSourceProject && forceRun ? base : packagePath;
  const { sourceVersion, targetVersion } = loadVersionInfo(versionSourcePath, base);

  // Carrega regras de c√≥pia
  const copyRulesSourcePath = isSourceProject && forceRun ? base : packagePath;
  const copyRules = loadCopyRules(copyRulesSourcePath);

  // Cria diret√≥rio .github se n√£o existir
  ensureDir(targetGithubPath);

  // Copia arquivos de configura√ß√£o
  const { updatedFiles, createdFiles, skippedFiles } = copyConfigFiles(
    sourceGithubPath,
    targetGithubPath,
    sourceVersion,
    targetVersion,
    copyRules
  );

  // Copia o arquivo version.json
  const sourceVersionFile = path.join(versionSourcePath, '.github', 'version.json');
  const targetVersionFile = path.join(targetGithubPath, 'version.json');

  if (fs.existsSync(sourceVersionFile)) {
    if (needsUpdate(sourceVersionFile, targetVersionFile, sourceVersion, targetVersion)) {
      copyFile(sourceVersionFile, targetVersionFile);
    }
  }

  // Relat√≥rio final
  console.log('\nüìä Summary:');
  console.log(`üìÑ Files created: ${createdFiles}`);
  console.log(`üîÑ Files updated: ${updatedFiles}`);
  console.log(`‚è≠Ô∏è Files skipped: ${skippedFiles}`);

  if (sourceVersion) {
    console.log(`üì¶ Package version: ${sourceVersion.version} (${sourceVersion.lastUpdated})`);
  }

  if (copyRules.version) {
    console.log(`üìã Copy rules version: ${copyRules.version}`);
  }

  if (isUpdate && updatedFiles > 0) {
    console.log('üéâ Configuration updated successfully after package update!');
  } else if (isInstall && createdFiles > 0) {
    console.log('üéâ GitHub Copilot configuration installed successfully!');
  } else {
    console.log('‚ú® GitHub Copilot configuration completed successfully!');
  }
}

// Executa apenas se chamado diretamente
if (require.main === module) {
  const forceRun = process.argv.includes('--force');
  initGithubConfig(forceRun);
}

module.exports = { initGithubConfig };
